
_ Реляционные БД или системы управления реляционными базами данных (СУРБД) предоставляют и хранят данные в таблицах и строках. С помощью SQL можно выполнять операции объединения между различными таблицами базы данных.. К самым популярным относятся MySQL, Oracle, PostgreSQL и т. д. _

_ Нереляционные БД (NoSQL) делятся на четыре категории: хранилища «ключ–значение», графовые, столбцовые и документные. Нереляционные БД обычно не поддерживают операции соединения. Популярностью пользуются CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB и т. д. _
##### NoSQL может быть более оптимален если:
* Приложение нуждается в крайне низкой латентности; 
* Данные не структурированы или не имеют никаких реляционных связей;
* Нужно лишь сериализовать и десериализовать свои данные (JSON, XML, YAML и т. д.);
* Нужно хранить огромные объемы данных


## ACID
Требования ACID — это набор свойств, которые обеспечивают надёжность транзакций в реляционных базах данных, таких как PostgreSQL. Разберем каждое свойство подробно и рассмотрим, как оно реализуется.
### Транзакция
**Транзакция** в PostgreSQL – это логическая группа SQL-операций, которые выполняются в рамках одной сессии и могут быть **зафиксированы (COMMIT)** или **отменены (ROLLBACK)** в зависимости от успеха выполнения.
Иное определение __транзакции__ - упорядоченное множество операций, **переводящих базу данных из одного согласованного состояния в другое**.
#### Базовые команды:

- `BEGIN;` – начинает транзакцию.
- `COMMIT;` – фиксирует все изменения в транзакции.
- `ROLLBACK;` – откатывает все изменения в транзакции.
- `SAVEPOINT` – создает точку восстановления внутри транзакции.

### Atomicity — Атомарность
Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.
Пример:
Не возникнет ситуации, что при переводе денег - средства снялись у отправителя, _но из-за какой-то проблемы не перечислились получателю_.

### Consistency — Согласованность
После завершения транзакции база данных **должна находиться в корректном состоянии**, соответствующем бизнес-логике. Данные не должны быть "сломаны".
После каждой проведенной транзакции проверяется, что база данных в корректном состоянии (нет нарушений бизнес логики):
- Ограничения (`PRIMARY KEY`, `FOREIGN KEY`, `CHECK`, `UNIQUE`).
- Типизация данных (`INTEGER`, `VARCHAR`, `TIMESTAMP` и т. д.).

## Isolation - Изоляция
Во время выполнения транзакции __параллельные__ транзакции не должны оказывать влияния на её результат.
Одна транзакция **не должна мешать** другой. В PostgreSQL изолированность регулируется **уровнями изоляции**

В примеру будем разбирать на основе проведения параллельных операций двумя транзакциями X и Y на каком-то счете. Изначально на нем будет 500 рублей.

| Аномалия               | Проблема                                                                                                                                                                                                                                                          | Пример                                                                                                                                                                                                                                                                |
| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Потерянное обновление  | Две транзакции читают одну и ту же строку таблицы, затем одна транзакция обновляет эту строку, а после этого вторая транзакция __тоже обновляет ту же строку, не учитывая изменений, сделанных первой транзакцией.__                                              | 1) Со счета сняли 300 (стало 200) - X<br>2) На счет положили 300 (без учета снятия стало 800, так как о нем ничего не известно) - Y<br>3) На счету окажется 800                                                                                                       |
| Грязное чтение         | Транзакция читает __еще не зафиксированные изменения__, сделанные другой транзакцией.                                                                                                                                                                             | 1) Списывают 300 (без commit) - X<br>2) Читают, что на счету сейчас 200 - Y<br>3) Откатывают X из-за ошибки или чего-либо еще<br>4) На счету 500, Y получил неверные данные                                                                                           |
| Неповторяющееся чтение | Транзакция читает одну и ту же строку __два раза__, и в промежутке __между чтениями вторая транзакция изменяет__ (или удаляет) эту строку и фиксирует изменения. Тогда первая транзакция получит __разные результаты__.                                           | 1) Планируется снять со счета 100 . Проверяется, что на счете > 100 - X<br>2) Снимается со счета 500 (с коммитом) - Y<br>3) Снимается со счета 100 - X<br>4) На счету -100 рублей (что запрещено констреинтами)                                                       |
| Фантомное чтение       | Транзакция __два раза читает набор строк по одному и тому же условию__, и в __промежутке__ между чтениями вторая транзакция __добавляет строки__, удовлетворяющие этому условию (и фиксирует изменения). Тогда первая транзакция получит __разные наборы строк.__ | 1) Клиенту можно иметь только 3 счета и у него их сейчас 2.<br>2) Клиент открывает счет, проверяется, что у него их всего 2 - X<br>3) Клиенту открылся новый счет (стало 3) - Y<br>4) Клиенту открылся новый счет (стало 4) - Y<br>5) Нарушено условие (макс 3 счета) |

_Ситуации, когда корректные транзакции некорректно работают вместе_, называются __аномалиями__ одновременного выполнения.
### Durability — Надёжность
Если пользователь получил подтверждение от системы, что транзакция выполнена (был commit), он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя. Обесточилась система, произошел сбой в оборудовании? На выполненную транзакцию это не повлияет.

PostgreSQL использует **Write-Ahead Logging (WAL)**, чтобы изменения сохранялись перед записью в БД.