## Из чего состоит отправка 1-ого запроса клиента

* Пользователь формирует сам или при помощи фронта запрос, который состоит из:
	* Метод
	* URL
	* Заголовки
	* Тело запросу (body)
* Получение ip адреса на основе домена в __DNS__.
* Установление соединения через __TCP (Transmission Control Protocol)__
* Установление защищенного соединения __(SSL/TLS защиты)__
* Формирование HTTP запроса
* Получение запроса на балансировщике и распределение его на нужный сервер
* Шифрование через SSL/TLS запроса (если используется HTTPS)
* Дешифрование и проверка сообщения (MAC для HTTPS)
* Обработка запроса
* Шифрование ответа (также для HTTPS)
* Получение ответа браузером, его расшифровка и проверка (для HTTPS)
* Отображение ответа

## Репликация базы данных
![](resources/Реплицирование%20базы%20данных.png)
### Типы реплицирования
- **Primary-Secondary (Master-Slave):**  
	Одна основная (мастер) база данных принимает все операции записи, а одна или несколько вторичных (реплик) синхронизируют данные с мастера и обслуживают запросы на чтение.
	_Преимущества:_ Простота реализации, хорошо подходит для распределения нагрузки на чтение.  
	_Недостатки:_ В случае отказа мастера требуется переключение (failover), а операции записи на вторичных узлах обычно недоступны.
- **Multi-Master (Master-Master):**  
    Несколько серверов могут одновременно принимать операции записи, а данные синхронизируются между ними.  
    _Преимущества:_ Позволяет распределять как операции чтения, так и записи, обеспечивает высокую доступность.  
    _Недостатки:_ Возможны конфликты при одновременной записи; требуется сложное управление согласованностью.
- **Clustered Replication:**  
    Применяется в распределённых системах (например, в NoSQL базах, таких как Cassandra или MongoDB), где данные реплицируются между узлами кластера, обеспечивая автоматическое распределение и отказоустойчивость.

Преимущества репликации базы данных: 
- Повышенная производительность. В модели «ведущий–ведомый» все операции записи и обновления происходят на ведущих узлах, а операции чтения распределяются между ведомыми. Это улучшает производительность, увеличивая количество запросов, которые можно обрабатывать параллельно. 
- Надежность. Если один из ваших серверов с базой данных сломается из-за стихийного бедствия, такого как тайфун или землетрясение, данные не будут утеряны. Вам не нужно беспокоиться о потере данных, так как они реплицируются по разным местам.
- Высокая доступность. За счет репликации данных по разным местам ваш веб-сайт будет продолжать работать, даже если одна из БД выйдет из строя, поскольку у вас по-прежнему будет доступ к данным, размещенным на другом сервере.

## Кэш

### Некоторые аспекты использования кэша
#### Когда будет использоваться кэш
Определитесь с тем, когда будет использоваться кэш. Это лучше делать в ситуациях, когда чтение данных происходит часто, а изменение — редко. В связи с тем, что кэш сбрасывается при перезапуске, данные необходимо записывать в постоянные хранилища.
#### Выбор срока действия кэша (TTL)
Просроченные данные немедленно удаляются. Срок действия лучше не делать слишком коротким, иначе система будет слишком часто обновлять данные, загружая их из БД. С другой стороны, из-за слишком длинного срока действия данные могут оказаться неактуальными.
#### Согласованность
Синхронизация данных в хранилище и кэше. Несогласованность может возникнуть из-за того, что операции изменения данных в хранилище и кэше выполняются не за одну транзакцию.
#### Предотвращение сбоев
Чтобы избежать SPOF (single point of failure), рекомендуется использовать несколько серверов кэширования, размещенных в разных центрах обработки данных (ЦОД). А еще можно выделить какой-нибудь дополнительный объем памяти: это создаст буфер на случай, если память начнет использоваться более активно.
#### Политика вытеснения
Когда кэш полностью заполнен, любой запрос на добавление новых элементов может привести к удалению существующих. Это называют вытеснением кэша. Самой популярной политикой считается вытеснение давно неиспользуемых данных (least-recently-used, LRU).

## Сессии
Данные сеансов клиентов __рекомендуется хранить в бд__, _так как иначе затрудняется горизонтальное масштабирование_

### Архитектура с сохранением состояния (на каждом сервере)
![](assets/Базовые%20моменты%20по%20архитектуре%20(Глава%201)/file-20250207020347652.png)

Чтобы клиент мог использовать сервер 1 и сервер 2, он должен аутентифицироваться на обоих из них, так как они не знают ничего друг о друге.
_Для решения проблемы, когда клиенту приходится аутентифицироваться несколько раз_, __балансировщики привязывают конкретного клиента только к определенному серверу__, но из-за этого может возникать множество проблем.

### Архитектура без сохранения состояния
![](assets/Базовые%20моменты%20по%20архитектуре%20(Глава%201)/file-20250207020705520.png)
В этой не хранящей состояние архитектуре пользовательские HTTP запросы __могут быть направлены любым веб-серверам__, которые __извлекают данные о состоянии из общего хранилища__. Хранилище отделено от веб-серверов.
__Такая архитектура позволяет значительно проще масштабировать систему горизонтально__.


## Центры обработки данных (ЦОД)
**ЦОД (Центр обработки данных)** — это специализированное сооружение или комплекс помещений, предназначенных для размещения, эксплуатации и обслуживания серверного и сетевого оборудования. __Проще говоря это набор серверов, которые могут изолированно от других хостить приложение.__

![](assets/Базовые%20моменты%20по%20архитектуре%20(Глава%201)/file-20250208002825999.png)

### Архитектурные моменты
- Трафик распределяется по определенным формулам (сколько процентов трафика ожидаем на сервере) или по ближайшему ЦОДу к клиенту.
- В случае если один из ЦОД упал, то трафик перенаправляется к еще живым.
- __Перенаправление трафика__. Необходимы эффективные инструменты для направления трафика к подходящему ЦОД (Пример: GeoDNS). 
- __Синхронизация данных__. Пользователи могут работать с разными локальными базами данных и кэшами в зависимости от региона. В случае сбоя трафик может быть перенаправлен к ЦОД, в котором нет запрашиваемых данных .__Для синхронизации данных между разными ЦОД можно использовать реплицирование и распределенные базы данных__.
- __Тесты и развертывание__. В конфигурации с несколькими ЦОД тестирование веб-сайта/приложения необходимо проводить в разных местах

## Очередь сообщений
__Очередь сообщений__ — это устойчивый компонент, который загружается в память и поддерживает асинхронное взаимодействие. Он служит буфером и распределяет асинхронные запросы. 
Сервисы ввода, так называемые __производители__, создают сообщения и публикуют их в очереди. Другие сервисы или серверы, которые называют __потребителями__, подключаются к очереди и выполняют действия, определенные в сообщениях.

![](assets/Базовые%20моменты%20по%20архитектуре%20(Глава%201)/file-20250208003731934.png)

Пример: Приложение поддерживает функции редактирования фотографий, такие как обрезка, повышение четкости и т. д. Для выполнения этих операций нужно какое-то время. Рабочие узлы достают задания из очереди и выполняют асинхронную обработку. Производитель и потребитель могут масштабироваться независимо друг от друга. Когда очередь становится слишком большой, для сокращения времени обработки добавляются новые рабочие узлы (потребители). Если же очередь в основном пустует, количество рабочих узлов можно уменьшить.

![](assets/Базовые%20моменты%20по%20архитектуре%20(Глава%201)/file-20250208003932829.png)

## Логирование, Метрики, Автоматизации
Если система доросла до обслуживания крупной компании, то рекомендуется добавлять инфраструктуру для повышения скорости разработки и степени надежности системы.

### Логирование
Логи можно отслеживать на каждом отдельном сервере, но есть также инструменты, позволяющие собирать их в централизованном сервисе ради удобства поиска и просмотра.

### Метрики
Сбор разного рода метрик помогает лучше понять предметную область и оценить работоспособность системы. Вам может пригодиться что-то из следующего: 
- метрики уровня сервера: процессор, память, дисковый ввод/вывод и т. д.; 
- агрегированные метрики: производительность всего уровня базы данных, уровня кэша и т. д.; 
- ключевые бизнес-метрики: суточное количество активных пользователей, удержание, доход и т. д
### Автоматизация
#### CI - непрерывная интеграция
**Непрерывная интеграция** — это практика, при которой код, изменённый разработчиками, часто (например, несколько раз в день) интегрируется в основную ветку репозитория. Это автоматический процесс, в ходе которого проверяется работоспособность кода (тесты) и его соответствие стандартам (статические анализаторы кода.

__Примеры технологий:__
1. **Jenkins**
    - Один из самых популярных инструментов для **непрерывной интеграции**. Jenkins автоматически запускает сборки и тесты каждый раз, когда в репозиторий поступает новый код. Он поддерживает разнообразные плагины для работы с различными языками программирования и инструментами.
2. **GitLab CI/CD**
    - Встроенная система CI/CD в платформу GitLab, которая позволяет автоматически запускать тесты, сборки и развертывание приложений после каждой фиксации кода. GitLab CI/CD тесно интегрирован с Git-репозиторием.
3. **CircleCI**
    - Платформа для CI/CD, которая ускоряет процесс тестирования и сборки. CircleCI позволяет запускать тесты на различных платформах и интегрироваться с системами GitHub и Bitbucket.
#### CD - непрерывное развертывание
**Непрерывное развертывание** — это практика, при которой код автоматически развертывается в рабочей среде, как только прошёл все тесты и проверки в процессе CI. Это обеспечивает более быструю доставку новых функций и исправлений в прод.
__Примеры технологий__:
1. **Docker**
    - Docker позволяет создавать контейнеры для приложений, которые можно легко развернуть в любой среде. В комбинации с инструментами для CI/CD, такими как Jenkins или GitLab CI, Docker позволяет автоматизировать развертывание и запуск приложений в контейнерах.
2. **Kubernetes**
    - Kubernetes — это система оркестрации контейнеров, которая помогает управлять развертыванием и масштабированием контейнеризованных приложений. В сочетании с CI/CD-инструментами, Kubernetes позволяет автоматизировать процесс развертывания приложений в облаке или на сервере.

#### Автоматизация сборки и тестирования

Автоматизация этих процессов помогает разработчикам сэкономить время на рутинных задачах, таких как компиляция кода, запуск тестов и проверка качества кода.
__Примеры технологий__:
1. **Maven / Gradle** (для Java)
    - Инструменты для автоматизации сборки проектов. Maven и Gradle позволяют разработчикам настроить сборку, запуск тестов и управление зависимостями.
2. **Webpack** (для JavaScript)
    - Инструмент для сборки и упаковки ресурсов (JavaScript, CSS, изображения) для веб-приложений. Он помогает с автоматизацией задач сборки в JavaScript-проектах, таких как минификация кода, преобразование типов файлов и др.

## Масштабирование базы данных
![](assets/Базовые%20моменты%20по%20архитектуре%20(Глава%201)/file-20250208011507193.png)
### Вертикальное масштабирование
Вертикальное масштабирование (или наращивание) подразумевает __повышение производительности существующего компьютера за счет добавления ресурсов__ процессора, памяти, диска и т. д.

__Недостатки__:
- Блокировки, конкуренция за общие ресурсы
- Единая точка отказа
- Мощные сервера очень дорогие

### Горизонтальное масштабирование
Горизонтальное масштабирование (или расширение) заключается __в добавлении новых серверов.__

__Шардинг__ позволяет __разделить__ крупные наборы данных на более мелкие и простые в использовании части, которые называют __шардами__. _Все шарды имеют одну и ту же схему, но каждый из них хранит уникальные данные._
Пример:
Сегментировать хранение пользователей по хэшу их id (по % количество шардов)

![](assets/Базовые%20моменты%20по%20архитектуре%20(Глава%201)/file-20250208012133325.png)
__Проблемы:__
- __Усложняет систему, создает доп. трудности__
- __Повторное сегментирование данных__ (если какие-то шарды неравномерно быстрее заполнились, потребуется переопредилить функцию, перераспределить данные)
- __Проблема знаменитостей__ (если на одном шарде очень часто будет идти обращение)
- __Соединение и денормализация__ После сегментирования базы данных между несколькими серверами становится сложно выполнять операции соединения, охватывающие несколько шардов. Распространенное решение состоит в денормализации базы данных таким образом, чтобы запросы могли выполняться в рамках одной таблицы.

## Выводы
Масштабирование системы — это пошаговый процесс. Если аудитория приложения больше нескольких миллионов, то потребуется дополнительные стратегии, но выше была приведена основа.

__Шаги по масштабированию системы:__
- веб-уровень не должен хранить состояния (сессии храним в бд);
- резервирование должно быть предусмотрено на каждом уровне (репликации, наличие нескольких подов приложения);
- кэширование данных следует проводить как можно более активно;
- система должна поддерживать больше одного центра обработки данных (ЦОД);
- статические ресурсы нужно хранить в CDN;
- для масштабирования данных следует применять шардинг;
- уровни должны быть разделены на отдельные сервисы;
- необходимо выполнять мониторинг системы и использовать средства автоматизации.