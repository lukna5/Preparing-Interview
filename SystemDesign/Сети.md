## Установление соединения через TCP (Transmission Control Protocol)
  ### Трехэтапное рукопожатие  ###
1) Клиент отправляет SYN (synchronize) с номером начальной последовательности
2) Сервер отвечает SYN-ACK (acknowledge) с новым номером начальной последовательности клиента и начальным номером последовательности сервера
3) Клиент подтверждает установку соединения и отправляет SYN-ACK с увеличенным номером последовательности сервера 

Пример:
_ Syn - у клиента и сервера свой, это номер последовательности именного этого участника _
_ Ack - также свой, какой номер последовательности ожидается от другого участник _

**1. Трёхэтапное рукопожатие (3-way handshake):**

- Клиент: отправляет SYN, Seq = 100.
- Сервер: отвечает SYN-ACK, Seq = 300, Ack = 101.
- Клиент: отправляет ACK, Seq = 101, Ack = 301.

Соединение установлено.

---

**2. Обмен данными:**

- Клиент: отправляет HTTP-запрос, Seq = 101, Ack = 301, данные длиной 50 байт.
- Сервер: подтверждает запрос клиента, Seq = 301, Ack = 151.
- Сервер: отправляет HTTP-ответ, Seq = 301, Ack = 151, данные длиной 100 байт.
- Клиент: подтверждает ответ сервера, Seq = 151, Ack = 401.

---

**3. Завершение соединения (4-way handshake):**

- Клиент: отправляет FIN, Seq = 151, Ack = 401.
- Сервер: подтверждает завершение от клиента, Seq = 401, Ack = 152.
- Сервер: отправляет FIN, Seq = 401, Ack = 152.
- Клиент: подтверждает завершение от сервера, Seq = 152, Ack = 402.

### Использование установленного TCP-соединения
#### Persistent Connections (Постоянные соединения)
- **По умолчанию в HTTP/1.1** - В HTTP/1.1 соединения по умолчанию считаются постоянными, то есть, если в заголовках запроса не указан `Connection: close`, соединение сохраняется после передачи запроса и ответа.
- __Механизм повторного использования__ - после получения ответа сервером TCP-соединение не закрывается сразу, а остается открытым. Это позволяет клиенту отправлять последующие HTTP-запросы по тому же TCP-соединению
- __HTTP/2 и multiplexing__ - В HTTP/2 механизм multiplexing позволяет одновременно передавать несколько потоков данных по одному TCP-соединению, что ещё эффективнее использует канал и снижает задержки.
#### Преимущества:
- **Снижение накладных расходов:** - Установка нового TCP-соединения требует времени и ресурсов (трехэтапное рукопожатие)
- **Уменьшение задержек** - Исключается дополнительная задержка на установление нового соединения

### Когда закрывается TCP-соединение
- __Явное закрытие соединения__
	- HTTP-заголовок `Connection: close`
	- Завершение работы приложения (закрытие браузера или приложения - открытые TCP-соединения закрываются автоматически)
- __Закрытие соединения по таймауту__
	- **Неактивность -** Если TCP-соединение остается неактивным в течение определенного времени (например, сервер или балансировщик нагрузки может иметь настройку таймаута), соединение закрывается автоматически
	- __Настройки сервера__ - Сервер может быть настроен так, чтобы закрывать соединение после определенного количества запросов или по истечении времени неактивности, даже если клиент не запросил закрытие явно
- __Прерывание соединения по ошибке__ - Если возникает сетевая ошибка или промежуточное устройство (например, балансировщик) решает закрыть соединение из-за проблем с производительностью или безопасностью, TCP-соединение может быть разорвано

### Механизм keep-alive
_Механизм keep-alive (постоянное соединение) позволяет поддерживать открытым TCP-соединение для передачи нескольких HTTP-запросов/ответов, вместо того чтобы закрывать его после каждого обмена_

В HTTP/1.0 требовалось указывать заголовок `Connection: keep-alive`.
В HTTP/1.1 и HTTP/2.0 постоянное соединение используется по умолчанию.

#### Управление временем жизни соединения
- **Таймаут keep-alive:** Обычно сервер устанавливает таймаут для неактивного соединения. Если в течение заданного времени (например, 30 секунд, 1 минуты или иной интервал, определяемый настройками) по соединению не происходит обмен данными, сервер закрывает соединение.
- **Количество запросов:** Помимо таймаута, сервер может ограничивать максимальное количество HTTP-запросов, которые могут быть переданы по одному TCP-соединению. После достижения этого лимита сервер закрывает соединение, чтобы начать "свежий" цикл для дальнейшей передачи данных.
## HTTP
HTTP (Hypertext Transfer Protocol) — это **протокол передачи гипертекста**, который позволяет клиентам (например, браузерам) и серверам обмениваться информацией в сети.
Упрощая - это правила общения между браузером и сервером

__Работает поверх TCP или TLS (в случае HTTPS).__

__Запросы передаются сформировавшись на основе протокола HTTP через TCP соединение.__
## SSL/TLS

_ CA (Certificate Authority) - это самый важный сертификат в системе доверия. Он выдан и подписан самим собой центром сертификации (и в браузерах и ОС есть информация о том, что он может выдавать сертификаты)._

**SSL/TLS-сертификат** — это цифровой документ, который:

1. **Подтверждает подлинность сервера** (вы уверены, что подключаетесь именно к `example.com`).
2. **Гарантирует безопасное соединение** через шифрование данных.

##### Сертификат содержит:

- **Доменное имя:** например, `example.com`.
- **Информация о владельце:** организация, страна.
- **Срок действия:** даты начала и окончания действия.
- **Публичный ключ:** ключ, используемый для шифрования данных.
- **Центр сертификации:** имя CA, который выдал сертификат (Пример: `Let’s Encrypt`).
- **Электронная подпись CA:** подтверждает, что сертификат был выдан доверенным центром.

##### Пример работы подписи:

1. CA берёт содержимое сертификата (данные о домене, публичный ключ и т.д.).
2. Применяет **хэш-функцию** (например, SHA-256), чтобы получить уникальное значение (хэш).
3. Шифрует этот хэш с помощью **приватного ключа** CA.
4. Получаем __ Цифровую подпись __

##### Как проверяется подпись?

- Клиент (например, браузер):
	1. Расшифровывает подпись с помощью **публичного ключа CA** (который доступен всем).
	2. Сравнивает расшифрованное значение с хэш-значением самого сертификата.
	3. Если всё совпадает, сертификат считается подлинным.


##### Как браузеры проверяют цепочку доверия?

_ Цепочка сертификатов (Certificate Chain): _

Каждый SSL/TLS-сертификат, который вы получаете от CA, связан с промежуточными и корневыми сертификатами. Пример цепочки:

`Ваш сертификат → Промежуточный сертификат CA → Корневой сертификат CA`

Проверяется каждый в цепочке, пока не дойдем до корневого, который есть в хранилище сертификатов.

### Генерация общего ключа шифрования сообщений
_Алгоритмы_
-  ___RSA___
  __Действие__: 
	1) Сервер предоставляет клиенту **публичный ключ (два числа сгенерированные на основе двух простых чисел)** через сертификат.
	2) Клиент генерирует общий (симметричный) ключ, шифрует его публичным ключом сервера и отправляет обратно.
	3) Сервер расшифровывает симметричный ключ с помощью своего **приватного ключа**.
	4) Клиент и сервер знают об общем симметричном ключе, который нельзя перехватить
	5) __Далее этот ключ используется для расшифрования и шифрования сообщений между клиентом и сервером__

 _Минусы_:
	1. **Отсутствие прямой секретности**: компрометация приватного ключа раскрывает все прошлые данные.
	2. **Большие размеры ключей**: 2048+ бит для адекватной безопасности.
	3. **Медленная работа**: медленнее, чем симметричные алгоритмы и современные протоколы (ECDHE).
	4. **Уязвимость к квантовым компьютерам**: требует перехода на новые стандарты.
	5. **Сложность настройки**: неправильная генерация или хранение ключей делает систему уязвимой.
	6. **Ограничение на размер данных**: RSA подходит только для шифрования небольших данных (например, симметричного ключа).

* ***ECDHE**
   Современный алгоритм для выработки общего ключа с использованием эллиптических кривых. _ Ключи уникальны для каждой сессии _
   __Действие__:
	   1) Клиент и сервер независимо генерируют временные (эпhemeral) **приватные ключи**.
	   2) Эти приватные ключи __остаются на устройствах и никогда не передаются__.
	   3) Каждая сторона вычисляет **публичный ключ** на основе эллиптической кривой.
	   4) Клиент и сервер обмениваются публичными ключами.
	   5) Общий секретный ключ вычисляется с использованием собственного приватного ключа и публичного ключа другой стороны (перемножаются).

 Преимущества:
	 1) **Прямая секретность:** Каждый сеанс использует временные ключи, поэтому компрометация приватного ключа сервера не позволяет расшифровать старые сессии.
	 2) **Высокая производительность:** Эллиптические кривые обеспечивают высокий уровень безопасности при меньшем размере ключа 256-битный ключ ECDHE эквивалентен 3072-битному RSA.
	 3) **Совместимость:** Широко используется в протоколах TLS (например, TLS 1.2 и TLS 1.3).**
## MAC
Гарантия целостности (Message Authentitication code).

__Необходим для гарантии__, что данные во время передачи __не были подменены__ злоумышленником или пришли до цели не с таким же содержимым из-за ошибок сети

Алгоритм:

 **1. Генерация MAC (отправителем):**

1. Отправитель берёт **сообщение** и **ключ** (общий симметричный).
2. Применяет алгоритм хэширования (например, SHA-256 или MD5).
3. Получает уникальный код (MAC), который зависит от:
    - Сообщения.
    - Ключа.
    - Алгоритма.

 **2. Проверка MAC (получателем):**

1. Получатель получает сообщение и MAC.
2. Заново вычисляет MAC из сообщения и ключа.
3. Сравнивает свой MAC с тем, который был отправлен.
    - Если они совпадают, сообщение целостное.
    - Если не совпадают, сообщение было изменено.
## TLS (Transport Layer Security)
_ TLS это улучшенная версия протокола SSL (Secure Socket Layer) _

_ Обеспечивает следующее: _
- **Шифрование данных**: Данные между клиентом (браузером) и сервером передаются в зашифрованном виде.
- **Аутентификацию сервера**: Клиент проверяет подлинность сервера (с помощью сертификата).
- **Целостность данных**: TLS гарантирует, что данные не были изменены злоумышленником в процессе передачи.
### Этапы работы TLS
1) Приветствие от клиента (Client Hello)
   Браузер инициирует подключение отправкой запроса, которое содержит
	   * - Версию протокола TLS, которую поддерживает клиент (например, TLS 1.2 или TLS 1.3).
	   * Список поддерживаемых алгоритмов шифрования (называются **Cipher Suites**).
	   * Случайное число (**Client Random**) — используется для выработки общего ключа.
	   * Другие параметры, например, поддерживаемые методы сжатия.
2) Ответ сервера (Server Hello)
   Сервер выполняет следующее
	   - Выбирает подходящий алгоритм шифрования (Cipher Suite) из предложенных клиентом.
	   - Отправляет случайное число (**Server Random**).
	   - Отправляет свой сертификат (SSL/TLS-сертификат), чтобы клиент мог проверить подлинность сервера.
	   - Если используется **TLS 1.3**, сервер может сразу отправить ключ для шифрования.
3) Проверка сертификата SSL/TLS клиентом (доверие к CA, совпадение домена, срок действия)
4) Генерация общего ключа для шифрования сообщений клиентом и сервером
5) Подтверждение готовности (Finished Message
	1) Клиент и сервер обмениваются сообщениями Finished
	2) Сообщения шифруются на основе общего ключе для проверки корректности ключей.
6) _Передача данных_ (с шифрованием сообщения) __весь запрос__ зашифровывается в набор байтов
7) Генерация __ MAC __ для __ защиты от подмены и добавление его к сообщению__
8) Получение данных (расшифровка сообщения на основе общего ключа)
9) Проверка совпадения MAC
10) Обработка запроса

## Балансировщик нагрузки

_Балансировщик нагрузки равномерно распределяет входящий трафик между веб-серверами_.
![[Балансировщик_пример.png]]
Доступ к веб-серверу есть только из внутренней сети, клиент получает доступ через балансировщик.
### Задачи
- Распределение трафика (минимизирует вероятность перегрузки отдельного узла)
- Обеспечение отказоустойчивости (если один их серверов выходит из строя, балансировщик будет перенаправлять трафик на другие работоспособные сервера)
- Масштабирование (добавление новых серверов в пул)
- Кэширование (иногда кэширует SSL-терминацию, иногда ответы на запросы и тд)
- Health check (периодически проверяет, что сервера живы)
- Rate limiting и throttling

### Типы балансировщиков
- __Аппаратные__ - это _специализированные физические устройства_, разработанные для высокопроизводительного распределения трафика.
	 Показывают крайне высокую производительность, но их значительно сложнее настраивать, а также они дороже.
- __Программные__ - это решения, _реализованные на уровне программного обеспечения_ , которые работают на стандартном серверном оборудовании, виртуальных машинах или контейнерах. Они выполняют функции распределения входящего трафика между несколькими серверными экземплярами.
	Легко настраиваются, низкие затраты железа, легко настраиваются, часто open-source, выполняет основную функцию балансировки.
	Пример: Njinx - __это высокопроизводительный веб-сервер и обратный прокси-сервер с открытым исходным кодом__.
	- Балансирует нагрузку между серверами
	- Статическая и динамическая выдача контента (может хранить файлы и выдавать их без необходимости ходить в бэкенд сервер)
	- SSL/TLS терминация, перед бэкенд сервером выполняет шифрование и дешифрование, чтобы снизить нагрузку на бэкенд сервера (передавая запросы уже в чистом виде).
	- Может кэшировать HTTP-запросы
- __Облачные__ - это управляемые сервисы, предоставляемые облачными провайдерами, которые автоматически распределяют входящий трафик между виртуальными машинами, контейнерами или другими ресурсами, размещёнными в облаке.
	Позволяет не задумываться о необходимости балансирования - все это делает облачный провайдер. Позволяет интегрироваться с другими облачными сервисами.
	__Но требует оплату по факту использования (количеству запросов)__

### Алгоритмы балансирования
- Round Robin - запросы по очереди направляются на следующий сервер (по кругу). Простой, но не учитывает текущую нагрузку или различия серверов.
- Weighted Round Robin - Каждому серверу присваивается вес в зависимости от его возможностей. Серверы с более высоким весом получают больше запросов, остальное как в Round Robin.
- Least Connections - Новый запрос направляется на сервер, у которого в данный момент меньше всего активных соединений.
- Weighted Least Connections - Сочетает принцип «наименьших соединений» с учетом весовых коэффициентов серверов.
- IP Hash - Балансировка производится на основании хэширования IP-адреса клиента. Это означает, что один и тот же клиент с определенным IP будет направлен всегда на один и тот же сервер.
- Random - Запрос направляется на случайно выбранный сервер из пула.
- Consistent Hashing - Используется преимущественно в распределенных системах и кэшах. Позволяет минимизировать переназначение ключей (например, при добавлении или удалении серверов) за счет сохранения большинства распределенных данных на тех же серверах. __Обеспечивает стабильность при изменениях пула серверов__.