## Установление соединения через TCP (Transmission Control Protocol)
  ### Трехэтапное рукопожатие  ###
1) Клиент отправляет SYN (synchronize) с номером начальной последовательности
2) Сервер отвечает SYN-ACK (acknowledge) с новым номером начальной последовательности клиента и начальным номером последовательности сервера
3) Клиент подтверждает установку соединения и отправляет SYN-ACK с увеличенным номером последовательности сервера 

Пример:
_ Syn - у клиента и сервера свой, это номер последовательности именного этого участника _
_ Ack - также свой, какой номер последовательности ожидается от другого участник _

**1. Трёхэтапное рукопожатие (3-way handshake):**

- Клиент: отправляет SYN, Seq = 100.
- Сервер: отвечает SYN-ACK, Seq = 300, Ack = 101.
- Клиент: отправляет ACK, Seq = 101, Ack = 301.

Соединение установлено.

---

**2. Обмен данными:**

- Клиент: отправляет HTTP-запрос, Seq = 101, Ack = 301, данные длиной 50 байт.
- Сервер: подтверждает запрос клиента, Seq = 301, Ack = 151.
- Сервер: отправляет HTTP-ответ, Seq = 301, Ack = 151, данные длиной 100 байт.
- Клиент: подтверждает ответ сервера, Seq = 151, Ack = 401.

---

**3. Завершение соединения (4-way handshake):**

- Клиент: отправляет FIN, Seq = 151, Ack = 401.
- Сервер: подтверждает завершение от клиента, Seq = 401, Ack = 152.
- Сервер: отправляет FIN, Seq = 401, Ack = 152.
- Клиент: подтверждает завершение от сервера, Seq = 152, Ack = 402.



## HTTP
HTTP (Hypertext Transfer Protocol) — это **протокол передачи гипертекста**, который позволяет клиентам (например, браузерам) и серверам обмениваться информацией в сети.
Упрощая - это правила общения между браузером и сервером

__Работает поверх TCP или TLS (в случае HTTPS).__

__Запросы передаются сформировавшись на основе протокола HTTP через TCP соединение.__
## SSL/TLS

_ CA (Certificate Authority) - это самый важный сертификат в системе доверия. Он выдан и подписан самим собой центром сертификации (и в браузерах и ОС есть информация о том, что он может выдавать сертификаты)._

**SSL/TLS-сертификат** — это цифровой документ, который:

1. **Подтверждает подлинность сервера** (вы уверены, что подключаетесь именно к `example.com`).
2. **Гарантирует безопасное соединение** через шифрование данных.

##### Сертификат содержит:

- **Доменное имя:** например, `example.com`.
- **Информация о владельце:** организация, страна.
- **Срок действия:** даты начала и окончания действия.
- **Публичный ключ:** ключ, используемый для шифрования данных.
- **Центр сертификации:** имя CA, который выдал сертификат (Пример: `Let’s Encrypt`).
- **Электронная подпись CA:** подтверждает, что сертификат был выдан доверенным центром.

##### Пример работы подписи:

1. CA берёт содержимое сертификата (данные о домене, публичный ключ и т.д.).
2. Применяет **хэш-функцию** (например, SHA-256), чтобы получить уникальное значение (хэш).
3. Шифрует этот хэш с помощью **приватного ключа** CA.
4. Получаем __ Цифровую подпись __

##### Как проверяется подпись?

- Клиент (например, браузер):
	1. Расшифровывает подпись с помощью **публичного ключа CA** (который доступен всем).
	2. Сравнивает расшифрованное значение с хэш-значением самого сертификата.
	3. Если всё совпадает, сертификат считается подлинным.


##### Как браузеры проверяют цепочку доверия?

_ Цепочка сертификатов (Certificate Chain): _

Каждый SSL/TLS-сертификат, который вы получаете от CA, связан с промежуточными и корневыми сертификатами. Пример цепочки:

`Ваш сертификат → Промежуточный сертификат CA → Корневой сертификат CA`

Проверяется каждый в цепочке, пока не дойдем до корневого, который есть в хранилище сертификатов.

### Генерация общего ключа шифрования сообщений
_Алгоритмы_
-  ___RSA___
  __Действие__: 
	1) Сервер предоставляет клиенту **публичный ключ (два числа сгенерированные на основе двух простых чисел)** через сертификат.
	2) Клиент генерирует общий (симметричный) ключ, шифрует его публичным ключом сервера и отправляет обратно.
	3) Сервер расшифровывает симметричный ключ с помощью своего **приватного ключа**.
	4) Клиент и сервер знают об общем симметричном ключе, который нельзя перехватить
	5) __Далее этот ключ используется для расшифрования и шифрования сообщений между клиентом и сервером__

 _Минусы_:
	1. **Отсутствие прямой секретности**: компрометация приватного ключа раскрывает все прошлые данные.
	2. **Большие размеры ключей**: 2048+ бит для адекватной безопасности.
	3. **Медленная работа**: медленнее, чем симметричные алгоритмы и современные протоколы (ECDHE).
	4. **Уязвимость к квантовым компьютерам**: требует перехода на новые стандарты.
	5. **Сложность настройки**: неправильная генерация или хранение ключей делает систему уязвимой.
	6. **Ограничение на размер данных**: RSA подходит только для шифрования небольших данных (например, симметричного ключа).

* ***ECDHE**
   Современный алгоритм для выработки общего ключа с использованием эллиптических кривых. _ Ключи уникальны для каждой сессии _
   __Действие__:
	   1) Клиент и сервер независимо генерируют временные (эпhemeral) **приватные ключи**.
	   2) Эти приватные ключи __остаются на устройствах и никогда не передаются__.
	   3) Каждая сторона вычисляет **публичный ключ** на основе эллиптической кривой.
	   4) Клиент и сервер обмениваются публичными ключами.
	   5) Общий секретный ключ вычисляется с использованием собственного приватного ключа и публичного ключа другой стороны (перемножаются).

 Преимущества:
	 1) **Прямая секретность:** Каждый сеанс использует временные ключи, поэтому компрометация приватного ключа сервера не позволяет расшифровать старые сессии.
	 2) **Высокая производительность:** Эллиптические кривые обеспечивают высокий уровень безопасности при меньшем размере ключа 256-битный ключ ECDHE эквивалентен 3072-битному RSA.
	 3) **Совместимость:** Широко используется в протоколах TLS (например, TLS 1.2 и TLS 1.3).**
## MAC
Гарантия целостности (Message Authentitication code).

__Необходим для гарантии__, что данные во время передачи __не были подменены__ злоумышленником или пришли до цели не с таким же содержимым из-за ошибок сети

Алгоритм:

 **1. Генерация MAC (отправителем):**

1. Отправитель берёт **сообщение** и **ключ** (общий симметричный).
2. Применяет алгоритм хэширования (например, SHA-256 или MD5).
3. Получает уникальный код (MAC), который зависит от:
    - Сообщения.
    - Ключа.
    - Алгоритма.

 **2. Проверка MAC (получателем):**

1. Получатель получает сообщение и MAC.
2. Заново вычисляет MAC из сообщения и ключа.
3. Сравнивает свой MAC с тем, который был отправлен.
    - Если они совпадают, сообщение целостное.
    - Если не совпадают, сообщение было изменено.
## TLS (Transport Layer Security)
_ TLS это улучшенная версия протокола SSL (Secure Socket Layer) _

_ Обеспечивает следующее: _
- **Шифрование данных**: Данные между клиентом (браузером) и сервером передаются в зашифрованном виде.
- **Аутентификацию сервера**: Клиент проверяет подлинность сервера (с помощью сертификата).
- **Целостность данных**: TLS гарантирует, что данные не были изменены злоумышленником в процессе передачи.
### Этапы работы TLS
1) Приветствие от клиента (Client Hello)
   Браузер инициирует подключение отправкой запроса, которое содержит
	   * - Версию протокола TLS, которую поддерживает клиент (например, TLS 1.2 или TLS 1.3).
	   * Список поддерживаемых алгоритмов шифрования (называются **Cipher Suites**).
	   * Случайное число (**Client Random**) — используется для выработки общего ключа.
	   * Другие параметры, например, поддерживаемые методы сжатия.
2) Ответ сервера (Server Hello)
   Сервер выполняет следующее
	   - Выбирает подходящий алгоритм шифрования (Cipher Suite) из предложенных клиентом.
	   - Отправляет случайное число (**Server Random**).
	   - Отправляет свой сертификат (SSL/TLS-сертификат), чтобы клиент мог проверить подлинность сервера.
	   - Если используется **TLS 1.3**, сервер может сразу отправить ключ для шифрования.
3) Проверка сертификата SSL/TLS клиентом (доверие к CA, совпадение домена, срок действия)
4) Генерация общего ключа для шифрования сообщений клиентом и сервером
5) Подтверждение готовности (Finished Message
	1) Клиент и сервер обмениваются сообщениями Finished
	2) Сообщения шифруются на основе общего ключе для проверки корректности ключей.
6) _Передача данных_ (с шифрованием сообщения) __весь запрос__ зашифровывается в набор байтов
7) Генерация __ MAC __ для __ защиты от подмены и добавление его к сообщению__
8) Получение данных (расшифровка сообщения на основе общего ключа)
9) Проверка совпадения MAC
10) Обработка запроса