__Кэш__ — это слой временного хранилища данных, который по своей скорости работы намного опережает БД и сетевые запросы. К преимуществам отдельного уровня кэша можно отнести улучшение производительности системы, возможность снизить нагрузку на отдельные компоненты.
![](resources/Кэш%20пример.png)

## Терминология 

- __cache miss - "промах кэша__". Сценарий, когда запрошенный ключ не был найден в кэше
- __cache hit - "попадание в кэш"__. Сценарий, когда запрошенный ключ был найден в кэше
- __hit ratio__ - % попаданий запросов в кэш. Характеризует эффективность кэширования.
- __горячий ключ__ - ключ, на который приходится бОльшая часть запросов
- __прогрев кэша__ - процесс наполнения кэша данными. Зачастую кэш прогревается либо при запуске системы заранее известными наиболее часто запрашиваемыми данными, либо по мере запросов(при частых или даже при первом cache miss)
- __инвалидация__ - удаление / обновление информации из кэша. Например, если в кэше находилось значение balance = 100\$, но пришел запрос на запись balance = 400\$, то очевидно что _после успешной записи_ нам необходимо инвалидировать это значение в кэше
## Стратегии кэширования

### Cache Through (ленивое кэширование через сервер кэширования)

__Приложение ничего не знает о бд, использует только кэш, а он уже отвечает за взаимодействие с бд.__
#### Read Through Cache 
В этой стратегии, когда есть попадание в кэш, приложение извлекает данные напрямую из кэша. В случае _пропуска кэша_ , здесь сервер кэша извлекает данные из базы данных, **а не из приложения** . Также после того, как данные извлекаются из базы данных, они сначала записываются в кэш, а затем возвращаются в наше приложение
![](assets/1/file-20250205221249792.png)
#### Write Through Cache (синхронная запись в кэш и бд)
__Очень похоже на Read Through Cache.__
_Сначала данные записываются в кэш, а далее обновляются в кэше, все это происходит синхронно._
![](assets/1/file-20250205221301904.png)

#### Плюсы

1. __Логика кэширования уже реализована абстрактно на сервере кэширования и в приложении не нужно задумываться над самостоятельной реализацией.__
2. Поскольку благодаря отложенной загрузке в кэш записываются только запрошенные данные, это позволяет избежать заполнения кэша ненужными данными.
3. Требуется синхронизация между кэшом и бд.
4. Соблюдается актуальность данных в кэше.

#### Минусы

1. В случае промаха кэша приводит к заметной задержке.
2. __Кэш изначально пуст.__
3. __Менее гибкий контроль приложения за кэшированием данных.__ Могут требоваться специфичные настройки под определенные сценарии.
4. __Запись довольна требовательная, за счет необходимости синхронизации данных в кэше и бд__
5. __Если кэш упал - то приложение не сможет получить данные.__

### Cache Aside (ленивое кэширование на уровне приложения)
#### Cache-aside (Read aside) - Кэш в стороне 
Приложение _сначала_ извлекает данные из кэша, прежде чем искать в базе данных. Если у нас есть _попадание в кэш,_ это означает, что данные найдены в кэше. В противном случае это _промах кэша_ . В этом случае приложение считывает данные из базы данных и обновляет содержимое кэша для будущих ссылок и возвращается в приложение. Это также известно как _ленивая загрузка_
![](assets/1/file-20250205221328003.png)

#### Write aside (Запись на стороне)
__Аналогично Write Through, но пишет в отдельный модуль отвечающий за кэширование__
![](assets/1/file-20250205221903358.png)
#### Плюсы

1. Гибкость. __Управление полностью в руках приложения. Оно может сохранить данные в кэш сразу после обращения к БД, а может предварительно сделать еще ряд манипуляций __с данными и только затем сохранить их в БД
2. Приложение работает даже в случае недоступности кэша.
3. Поскольку благодаря отложенной загрузке в кэш записываются только запрошенные данные, это позволяет избежать заполнения кэша ненужными данными.
4. __Упрощается настройка кэширования под определенные сценарии для приложения.__

#### Минусы

1. Каждый _промах кэша_ приводит к заметной задержке.
2. __Изначально кэш будет пустым, что приведет к _промахам кэша_ для большинства запросов. В результате время задержки увеличится.__
3. __В каждом приложении потребуется реализовывать логику взаимодействия кэша и бд.__

### Write Back / Write Behind (запись в кэш -> запись в базу с задержкой)
Операция записи сначала выполняется в кэше, но затем все данные записываются _асинхронно_ в базу данных через определенный промежуток времени
![](assets/1/file-20250205005529518.png)

**Плюсы**

1. Устойчив к сбоям современных баз данных.
2. __Снижение нагрузки и затрат за счет сокращения количества записей в базу данных__.

**Минусы**

1. В случае любой прямой операции с базой данных мы можем столкнуться с использованием устаревших данных, что формально называется __возможной несогласованностью__ между базой данных и сервером кэширования.
2. __В случае сбоя кэша__ может произойти _безвозвратная потеря данных ._
### Write Around (запись только в бд, чтение только из кэша)
__Приложение записывает данные напрямую в базу данных__. А чтение данных проходит через кэш. Для операции чтения мы используется либо стратегия cache aside, либо стратегия cache through.
Может пригодится в системах с большим объемом данных, где они часто записываются, но читаются не так часто.
![](assets/1/file-20250205005624407.png)

__Плюсы (преимущества)__
1. **Снижение «загрязнения» кэша.** Экономится память в кэше, за счет игнорирования запоминания новых записанных в бд значений.
2. **Сокращение нагрузки на кэш при большом количестве записей:** Запись выполняется довольно быстро
3. Простая реализация

__Минусы (недостатки)__
1. При **первом запросе** данных после их обновления в базе они отсутствуют в кэше. Часто возникает __cache miss__
2. __Данные в кэше могут быть не актуальны__, так как после записи в бд, нет обновления кэша
### Cache Ahead (асинхронное обновление кэша)
__Эта стратегия предназначена только для запросов на чтение. Они всегда идут только в кэш,__ никогда не попадая в БД напрямую. По факту __мы работаем со снимком состояния БД и обновляем его с некоторой периодичностью__. Для приложения это выглядит просто как хранилище, как и в случае Cache Through.
Можно комбинировать с другими Write стратегиями.
![](assets/1/file-20250205221056386.png)

#### Преимущества:

1. Минимальная и полностью контролируемая нагрузка на БД. __Клиентские запросы не могут повлиять на БД.__
2. __Всегда быстрый ответ на read запросы__
3. В коде легко добавить/убрать кэш, поскольку можно просто заменить кэш на основное хранилище и обращаться уже к нему

#### Недостатки:

1. __Кэш часто может быть не актуален__. Он отстает от основного хранилища __на период между запусками обновления кэша__. Нужно помнить, что на момент обращения __свежие данные могут еще “не доехать” до кэша__. Эта проблема может быть решена использованием сквозной записи или записи на стороне. Тогда, при обновлении данных в БД, данные будут обновляться и в кэше.
2. Требует очень много памяти.

## Стратегии инвалидации
__Инвалидация__ – это процесс удаления данных из кэша или пометка их как недействительных. Делается это для того, чтобы гарантировать актуальность данных, с которыми работает приложение.

### По TTL
### По событию
## Стратегии вытеснения
__Размер кэша ограничен__, он гораздо меньше основного хранилища, а значит, мы не может разместить в нем все данные. Что делать, когда память, выделенная под кэш, полностью заполнена, а новые записи продолжают поступать?