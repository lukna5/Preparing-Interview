Развитие систем привело к тому, что повышение скорости ядра процессов уже становится крайне затруднительным.
![](assets/Введение%20и%20история/file-20250205001349276.png)
### Закон Мура
**Закон Мура** — это наблюдение, сделанное американским инженером и соучредителем Intel Гордоном Муром в 1965 году. **Согласно ему, количество транзисторов на интегральной микросхеме удваивается примерно каждые два года**
![[Закон Мура.png]]
Из графика можно заметить, что:
1) Количество транзисторов на процессоре продолжает расти
2) Производительность (частота процессора) значительно медленнее стало расти
3) Потребление энергии растет примерно с такой же скоростью
4) С 2005-ого года начали пихать в процессоры множество ядер (за счет чего общая вычислительная мощность процессоров продолжила расти)

### Закон Амдала
**В случае, когда задача разделяется на несколько частей, суммарное время её выполнения на параллельной системе не может быть меньше времени выполнения самого медленного фрагмента**
Формула:
![[Закон_Амдала_Формула.png]]

График:
![[Закон_Амдала_График.png]]

__Вывод:
Для масштабируемости нужно больше параллелизма (размера кода, который может быть выполнен параллельно с другими потоками)

### Параллелизм на уровне инструкций (ILP)
ILP - instruction level parallelism
Параллелизация операций, которые независимы друг от друга
Улучшение процессоров позволяет не думать программисту самостоятельно о параллелизме (но уже приходится)

 Способы использования ILP:
 * Конвейер
 * Суперскалярное выполнение
 * Длинное машинное слово (VLIW - very long instruction word)
 * Векторизация (SIMD)

Современные процессоры - суперскалярные (может выполнять несколько инструкций за такт) и одновременное векторные (выполнение операций над векторами).

_Рост благодаря улучшению процессоров стал значительно замедляться, теперь программисту нужно самому параллелить код_


### Модели мультипроцессорности

- Симметричная (SMP)
![[SMP.png]]
* Одновремеменная (SMT)
![[SMT.png]]
* Асимметричная (NUMA)![[NUMA.png]]



## История операционных систем с многозадачности
_Хотим эффективнее эксплуатировать системы.._
### Типы
- Однозадачные
- Система с пакетными заданиями (batch processing)
- Многозадачные / с разделением времени
	- Кооперативная многозадачность (программист сам пишет, где нужно выдать время определенной программе)
	- Вытесняющая многозадачность (процесс думает, что он постоянной выполняется, но на деле ОС выполняет его и какими-то интервалами (пример - 25 мс) отдает процессор другим задачам незаметно для процесса).
	 __ ОС создает иллюзию для программы, что она единственная для машины__
### История многозадачности
- Изначально нужно было для раздела одной дорогой машины между разными пользователями
- Теперь нужно для использования ресурсов одной многоядерной машины для множества задач

## TSO (Total Store Order) модель памяти
Модель памяти процессора, которая позволяет объяснить процесс выполнения многопоточной программы. Использовалась на x86.
Cyть в том, что операции на запись сначала попадают в буфер записи. А чтение сразу идет в память.
Здесь байка о том, __как могло получится (0, 0)__, если в коде это невозможно.
Запись отложена, поэтому сначала может прочитать в обоих случаях 0.
![[TSO Example.png]]

